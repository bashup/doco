#!/usr/bin/env bash
# ---
# This file is automatically generated from doco.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2017 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set -euo pipefail  # Strict mode
mdsh-parse() {
	local cmd=$1 lno=0 block_start lang block ln indent fence close_fence indent_remove
	local open_fence=$'^( {0,3})(~~~+|```+) *([^`]*)$'
	while ((lno++)); IFS= read -r ln; do
		if [[ $ln =~ $open_fence ]]; then
			indent=${BASH_REMATCH[1]} fence=${BASH_REMATCH[2]} lang=${BASH_REMATCH[3]} block=
			block_start=$lno close_fence="^( {0,3})$fence+ *\$" indent_remove="^${indent// / ?}"
			while ((lno++)); IFS= read -r ln && ! [[ $ln =~ $close_fence ]]; do
				! [[ $ln =~ $indent_remove ]] || ln=${ln#${BASH_REMATCH[0]}}; block+=$ln$'\n'
			done
			lang="${lang%"${lang##*[![:space:]]}"}"; "$cmd" fenced "$lang" "$block";
		fi
	done
}
mdsh-source() {
	local MDSH_FOOTER='' MDSH_SOURCE
	if [[ ${1:--} != '-' ]]; then
		MDSH_SOURCE="$1"
		mdsh-parse __COMPILE__ <"$1"
	else mdsh-parse __COMPILE__
	fi
	${MDSH_FOOTER:+ printf %s "$MDSH_FOOTER"}; MDSH_FOOTER=
}
mdsh-compile() (  # <-- force subshell to prevent escape of compile-time state
	mdsh-source "$@"
)
__COMPILE__() {
	[[ $1 == fenced && $fence == $'```' && ! $indent ]] || return 0  # only unindented ``` code
	local lang="${2//[^_[:alnum:]]/_}"; # convert language to safe variable/function name
	local tag_words; mdsh-splitwords "$2" tag_words;  # check for command blocks first
	if [[ ${tag_words[1]-} == '!'* ]]; then
		set -- "$3" "$2" "$block_start"; eval "${2#*!}"; return
	elif [[ ${tag_words[1]-} == '+'* ]]; then
		printf '%s %q\n' "${2#"${tag_words[0]}"*+}" "$3"
	elif [[ ${tag_words[1]-} == '|'* ]]; then
		echo "${2#"${tag_words[0]}"*|} <<'\`\`\`'"; printf $'%s```\n' "$3"; return
	elif fn-exists "mdsh-lang-$lang"; then
		mdsh-rewrite "mdsh-lang-$lang" "{" "} <<'\`\`\`'"; printf $'%s```\n' "$3"
	elif fn-exists "mdsh-compile-$lang"; then
		"mdsh-compile-$lang" "$3" "$2" "$block_start"
	else
		mdsh-misc "$2" "$3"
	fi

	if fn-exists "mdsh-after-$lang"; then
		mdsh-rewrite "mdsh-after-$lang"
	fi
}
# split words in $1 into the array named by $2 (REPLY by default), without wildcard expansion
mdsh-splitwords() {
	set -f -- "$-" "$@";  eval "${3:-REPLY}"'=($2)'; [[ $1 == *f* ]] || set +f
}
# fn-exists: succeed if argument is a function
fn-exists() { declare -F -- "$1"; } >/dev/null
# Output body of func $1, optionally replacing the opening/closing { and } with $2 and $3
mdsh-rewrite() {
	local b='}' r; r="$(declare -f -- "$1")"; r=${r#*{ }; r=${r%\}*}; echo "${2-{}$r${3-$b}"
}
mdsh-misc()          { mdsh-data "$@"; }    # Treat unknown languages as data
mdsh-compile-()      { :; }                 # Ignore language-less blocks

mdsh-compile-mdsh()  { eval "$1"; }         # Execute `mdsh` blocks in-line
mdsh-compile-mdsh_main() { ! @is-main || eval "$1"; }

mdsh-compile-shell() { printf '%s' "$1"; }  # Copy `shell` blocks to the output
mdsh-compile-shell_main() { ! @is-main || printf '%s' "$1"; }
mdsh-data() {
	printf 'mdsh_raw_%s+=(%q)\n' "${1//[^_[:alnum:]]/_}" "$2"
}
mdsh-compile-shell_mdsh() {
	indent='' fence=$'```' __COMPILE__ fenced mdsh "$1"
}
mdsh-compile-shell_mdsh_main() {
	indent='' fence=$'```' __COMPILE__ fenced "mdsh main" "$1"
}
# Main program: check for arguments and run markdown script
mdsh-main() {
	(($#)) || mdsh-error "Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]" "${0##*/}"
	case "$1" in
	--) mdsh-interpret "${@:2}" ;;
	--*|-?) fn-exists "mdsh.$1" || mdsh-error "%s: unrecognized option: %s" "${0##*/}" "$1"
		"mdsh.$1" "${@:2}"
		;;
	-??*) mdsh-main "${1::2}" "-${1:2}" "${@:2}" ;;  # split '-abc' into '-a -bc' and recurse
	*)  mdsh-interpret "$@" ;;
	esac
}
# Run markdown file as main program, with $0 == $BASH_SOURCE == "" and
# MDSH_ZERO pointing to the original $0.

function mdsh-interpret() {
	printf -v cmd $'eval "$(%q --compile %q)"' "$0" "$1"
	MDSH_ZERO="$1" exec bash -c "$cmd" "" "${@:2}"
}
mdsh.--compile() {
	(($#)) || mdsh-error "Usage: %s --compile FILENAME..." "${0##*/}"
	! fn-exists mdsh:file-header || mdsh:file-header
	for REPLY; do mdsh-compile "$REPLY"; done
	! fn-exists mdsh:file-footer || mdsh:file-footer
}

mdsh.-c() { mdsh.--compile "$@"; }
mdsh.--eval() {
	{ (($# == 1)) && [[ $1 != - ]]; } ||
		mdsh-error "Usage: %s --eval FILENAME" "${0##*/}"
	mdsh.--compile "$1"
	echo $'__status=$? eval \'return $__status || exit $__status\' 2>/dev/null'
}

mdsh.-E() { mdsh.--eval "$@"; }
mdsh.--out() {
	if REPLY=("$(mdsh-main "${@:2}")"); then
		exec echo "$REPLY" >"$1"   # handle self-compiling properly
	else exit $?;
	fi
}

mdsh.-o() { mdsh.--out "$@"; }
# mdsh-error: printf args to stderr and exit w/EX_USAGE (code 64)
# shellcheck disable=SC2059  # argument is a printf format string
mdsh-error() { printf "$1"'\n' "${@:2}" >&2; exit 64; }
mdsh.--help() {
	printf 'Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]\n' "${0##*/}"
	echo $'
Run and/or compile code blocks from markdownfile(s) to bash.
Use a filename of `-` to run or compile from stdin.

Options:
  -h, --help                Show this help message and exit
  -c, --compile MDFILE...   Compile MDFILE(s) to bash and output on stdout.
  -E, --eval MDFILE         Compile one file w/a shelldown-support footer line\n'
}

mdsh.-h() { mdsh.--help "$@"; }
MDSH_LOADED_MODULES=
MDSH_MODULE=

@require() {
	flatname "$1"
	if ! [[ $MDSH_LOADED_MODULES == *"<$REPLY>"* ]]; then
		MDSH_LOADED_MODULES+="<$REPLY>"; local MDSH_MODULE=$1
		"${@:2}"
	fi
}
@is-main() { ! [[ $MDSH_MODULE ]]; }
@module() {
	@is-main || return 0
	set -- "${1:-${MDSH_SOURCE-}}"
	echo "#!/usr/bin/env bash"
	echo "# ---"
	echo "# This file is automatically generated from ${1##*/} - DO NOT EDIT"
	echo "# ---"
	echo
}
@main() {
	@is-main || return 0
	MDSH_FOOTER=$'if [[ $0 == "${BASH_SOURCE-}" ]]; then '"$1"$' "$@"; fi\n'
}
@comment() (  # subshell for cd
	! [[ "${MDSH_SOURCE-}" == */* ]] || cd "${MDSH_SOURCE%/*}"
	sed -e 's/^\(.\)/# \1/; s/^$/#/;' "$@"
	echo
)
mdsh-embed() {
	local f=$1 base=${1##*/}; local boundary="# --- EOF $base ---" contents ctr=
	[[ $f == */* && -f $f ]] || f=$(command -v "$f") || {
		echo "Can't find module $1" >&2; return 69  # EX_UNAVAILABLE
	}
	contents=$'\n'$(<"$f")$'\n'
	while [[ $contents == *$'\n'"$boundary"$'\n'* ]]; do
		((ctr++)); boundary="# --- EOF $base.$ctr ---"
	done
	printf $'{ if [[ $OSTYPE != cygwin && $OSTYPE != msys && -e /dev/fd/0 ]]; then source /dev/fd/0; else source <(cat); fi; } <<\'%s\'%s%s\n' "$boundary" "$contents" "$boundary"
}
mdsh-make() {
	[[ -f "$1" && -f "$2" && ! "$1" -nt "$2" && ! "$1" -ot "$2" ]] || {
		( "${@:3}" && mdsh-main --out "$2" --compile "$1" ) && touch -r "$1" "$2"
	}
}
mdsh-cache() {
	[[ -d "$1" ]] || mkdir -p "$1"
	flatname "${3:-$2}"; REPLY="$1/$REPLY"; mdsh-make "$2" "$REPLY" "${@:4}"
}
flatname() {
	REPLY="${1//\%/%25}"; REPLY="${REPLY//\//%2F}"; REPLY="${REPLY/#./%2E}"
	REPLY="${REPLY//</%3C}"; REPLY="${REPLY//>/%3E}"
	REPLY="${REPLY//\\/%5C}"
}
MDSH_CACHE=
mdsh-use-cache() {
	if ! (($#)); then
		set -- "${XDG_CACHE_HOME:-${HOME:+$HOME/.cache}}"
		set -- "${1:+$1/mdsh}"
	fi
	MDSH_CACHE="$1"
}
mdsh-use-cache
mdsh-run() {
	if [[ ${MDSH_CACHE-} ]]; then
		mdsh-cache "$MDSH_CACHE" "$1" "${2-}"
		source "$REPLY" "${@:3}"
	else run-markdown "$1" "${@:3}"
	fi
}
# run-markdown file args...
# Compile `file` and source the result, passing along any positional arguments
run-markdown() {
	if [[ $BASH_VERSINFO == 3 ]]; then # bash 3 can't source from proc
		# shellcheck disable=SC1091  # shellcheck shouldn't try to read stdin
		source /dev/fd/0 "${@:2}" <<<"$(mdsh-source "${1--}")"
	else source <(mdsh-source "${1--}") "${@:2}"
	fi
}
mdsh_raw_bash_runtime+=($'#!/usr/bin/env bash\n\n# --- BEGIN jqmd runtime ---\n')
mdsh_raw_bash_runtime+=($'jqmd_imports=\njqmd_filters=\njqmd_defines=\n\nHAVE_FILTERS() { [[ ${jqmd_filters-} ]]; }\nCLEAR_FILTERS() { unset jqmd_filters; JQ_OPTS=(jq); }\n\nIMPORTS() { jqmd_imports+="${jqmd_imports:+$\'\\n\'}$1"; }\nDEFINE()  { jqmd_defines+="${jqmd_defines:+$\'\\n\'}$1"; }\nFILTER()  {\n\tcase $# in\n\t1) jqmd_filters+="${jqmd_filters:+|}$1"; return ;;\n\t0) return ;;\n\tesac\n\tlocal REPLY ARGS=(printf -v REPLY "$1"); shift\n\tJSON-QUOTE "$@"; ARGS+=("${REPLY[@]}"); "${ARGS[@]}"; FILTER "$REPLY"\n}\n\nJSON-QUOTE() {\n\tset -- "${@//\\\\/\\\\\\\\}";   set -- "${@//\\"/\\\\\\"}"   # \\ and "\n\tset -- "${@//$\'\\n\'/\\\\n}"; set -- "${@//$\'\\r\'/\\\\r}"; set -- "${@//$\'\\t\'/\\\\t}"  # \\n\\r\\t\n\tset -- "${@/#/\\"}";       set -- "${@/%/\\"}"  # leading and trailing \'"\'\n\tREPLY=(); local s r\n\twhile (($#)); do\n\t\ts=${1//[^$\'\\x01\'-$\'\\x1F\']/};\n\t\twhile [[ $s ]]; do\n\t\t\tprintf -v r \\\\\\\\u%04x "\'${s:0:1}"\n\t\t\tset -- "${@//"${s:0:1}"/"$r"}"\n\t\t\ts=${s//"${s:0:1}"/}\n\t\tdone\n\t\tREPLY+=("$1"); shift\n\tdone\n}\n')
mdsh_raw_bash_runtime+=($'JQ_OPTS=(jq)\nJQ_OPTS() { JQ_OPTS+=("$@"); }\nARG()     { JQ_OPTS --arg     "$1" "$2"; }\nARGJSON() { JQ_OPTS --argjson "$1" "$2"; }\nARGQUOTE() { REPLY=JQMD_QA_${#JQ_OPTS[@]}; ARG "$REPLY" "$1"; REPLY=\'$\'$REPLY; }\n')
mdsh_raw_bash_runtime+=($'JQ_CMD() {\n\tlocal f= opt nargs cmd=(jq); set -- "${JQ_OPTS[@]:1}" "$@"\n\n\twhile (($#)); do\n\t\tcase "$1" in\n\t\t-f|--fromfile)\n\t\t\topt=$(<"$2") || return 69\n\t\t\tFILTER "$opt"; shift 2; continue\n\t\t\t;;\n\t\t-L|--indent)                            nargs=2 ;;\n\t\t--arg|--arjgson|--slurpfile|--argfile)  nargs=3 ;;\n\t\t--)  break   ;; # rest of args are data files\n\t\t-*)  nargs=1 ;;\n\t\t*)   FILTER "$1"; break ;;\t# jq program: data files follow\n\t\tesac\n\t\tcmd+=("${@:1:$nargs}")\t# add $nargs args to cmd\n\t\tshift $nargs\n\tdone\n\n\tHAVE_FILTERS || FILTER .    # jq needs at least one filter expression\n\tfor REPLY in "${jqmd_imports-}" "${jqmd_defines-}" "${jqmd_filters-}"; do\n\t\t[[ $REPLY ]] && f+=${f:+$\'\\n\'}$REPLY\n\tdone\n\n\tREPLY=("${cmd[@]}" "$f" "${@:2}")\n\tCLEAR_FILTERS   # cleanup for any re-runs\n}\n\nRUN_JQ() { JQ_CMD "$@" && "${REPLY[@]}"; }\nCALL_JQ() { JQ_CMD "$@" && REPLY=("$("${REPLY[@]}")"); }\n')
mdsh_raw_bash_runtime+=($'YAML()  { y2j "$1"; JSON "$REPLY"; }\nJSON()  { FILTER "jqmd_data($1)" "${@:2}"; }\n')
mdsh_raw_bash_runtime+=($'DEFINE \'\ndef jqmd::blend($other; combine): . as $this | . *  $other | . as $combined | with_entries(\n  if (.key | in($this)) and (.key | in($other)) then\n    .this = $this[.key] | .other = $other[.key] | combine\n  else . end\n);\n\ndef jqmd::combine: (.this|type) as $this | (.other|type) as $other | .value =\n  if $this == "array" then\n    if $other == "array" then .this + .other else .this + [.other] end\n  elif $this == "object" then\n    if $other == "object" then\n      .other as $o | (.this | jqmd::blend($o; jqmd::combine))\n    else .other end\n  else .other end;  # everything else just overrides\n\ndef jqmd::data($data): {this: ., other:$data} | jqmd::combine | .value ;\ndef jqmd_data($data): jqmd::data($data) ;\n\'\n')
mdsh_raw_bash_runtime+=($'y2j() {\n\tlocal p j="$(echo "$1" | yaml2json)" || return $?; REPLY=\n\twhile [[ $j == *\'\\\\(\'* ]]; do\n\t\tp=${j%%\'\\\\(\'*}; j=${j#"$p"\'\\\\(\'}\n\t\tif [[ $p =~ (^|[^\\\\])(\'\\\\\\\\\')*$ ]]; then\n\t\t\tp="${p}"\'\\(\' # odd, unbalance the backslash\n\t\telse\n\t\t\tp="${p}("   # even, remove one actual backslash\n\t\tfi\n\t\tREPLY+=$p\n\tdone\n\tREPLY+=$j\n}\n')
mdsh_raw_bash_runtime+=($'yaml2json:cmd() { command yaml2json /dev/stdin; }\n\nyaml2json:py() {\n\tpython -c \'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout)\'\n}\n\nyaml2json:php() { command yaml2json.php; }\n\nyaml2json() {\n\tlocal kind  # auto-select between available yaml2json implementations\n\tfor kind in cmd py php; do\n\t\tREPLY=($(yaml2json:$kind < <(echo "a: {}") 2>/dev/null || true))\n\t\tprintf -v REPLY %s ${REPLY+"${REPLY[@]}"}\n\t\tif [[ "$REPLY" == \'{"a":{}}\' ]]; then\n\t\t\teval "yaml2json() { yaml2json:$kind; }"; yaml2json; return\n\t\tfi\n\tdone\n\tmdsh-error "To process YAML, must have one of: yaml2json, PyYAML, or yaml2json.php"\n\texit 69 # EX_UNAVAILABLE\n}\n\n# --- END jqmd runtime ---\n')
# Language Support
mdsh-compile-jq()         { printf 'FILTER %q\n' "$1"$'\n'; }
mdsh-compile-jq_defs()    { printf 'DEFINE %q\n' "$1"$'\n'; }
mdsh-compile-jq_imports() { printf 'IMPORTS %q\n' "$1"$'\n'; }

mdsh-compile-yml()  { y2j "$1"; mdsh-compile-json "$REPLY"; }
mdsh-compile-yaml() { y2j "$1"; mdsh-compile-json "$REPLY"; }
mdsh-compile-json() { mdsh-compile-jq "jqmd_data($1)"; }

const() {
	case "${tag_words-}" in
	yaml|yml) y2j "$block"; printf 'DEFINE %q\n' "def $1: $REPLY ;"$'\n' ;;
	json)     printf 'DEFINE %q\n' "def $1: $block ;"$'\n' ;;
	*) mdsh-error "Invalid language for constant: '%s'" "${tag_words-}"
	esac
}
# Load the runtime so it's usable by mdsh
printf -v REPLY '%s\n' "${mdsh_raw_bash_runtime[@]}"; eval "$REPLY"

# Add runtime to the top of compiled (main) scripts
printf -v REPLY 'mdsh:file-header() { ! @is-main || echo -n %q; }' "$REPLY"; eval "$REPLY"

# Ensure (main) scripts process any leftover filters at end
mdsh:file-footer() { ! @is-main || echo $'if [[ $0 == "${BASH_SOURCE[0]-}" ]] && HAVE_FILTERS; then RUN_JQ; fi'; }
mdsh.--no-runtime() ( unset -f mdsh:file-header mdsh:file-footer; mdsh-main "$@"; )
mdsh.--yaml() (
	fn-exists "yaml2json:${1-}" || mdsh-error "No such yaml2json processor: ${1-}" || exit $?
	eval 'yaml2json() { yaml2json:'"$1"'; }'
	mdsh-main "${@:2}"
)

mdsh.-R() { mdsh.--no-runtime "$@"; }
mdsh.-y() { mdsh.--yaml "$@"; }
#!/usr/bin/env bash

realpath.location(){ realpath.follow "$1"; realpath.absolute "$REPLY" ".."; }
realpath.resolved(){ realpath.follow "$1"; realpath.absolute "$REPLY"; }
realpath.dirname() { if [[ $1 =~ /+[^/]+/*$ ]]; then REPLY="${1%${BASH_REMATCH[0]}}"; REPLY=${REPLY:-/}; else REPLY=.; fi }
realpath.basename(){ if [[ $1 =~ /*([^/]+)/*$ ]]; then REPLY="${BASH_REMATCH[1]}"; else REPLY=/; fi }

realpath.follow() {
	local target
	while [[ -L "$1" ]] && target=$(readlink -- "$1"); do
		realpath.dirname "$1"
		# Resolve relative to symlink's directory
		[[ $REPLY != . && $target != /* ]] && REPLY=$REPLY/$target || REPLY=$target
		# Break out if we found a symlink loop
		for target; do [[ $REPLY == "$target" ]] && break 2; done
		# Add to the loop-detect list and tail-recurse
		set -- "$REPLY" "$@"
	done
	REPLY="$1"
}

realpath.absolute() {
	REPLY=$PWD; local eg=extglob; ! shopt -q $eg || eg=; ${eg:+shopt -s $eg}
	while (($#)); do case $1 in
		/*) REPLY=/; set -- "${1##+(/)}" "${@:2}" ;;
		*/*) set -- "${1%%/*}" "${1##${1%%/*}+(/)}" "${@:2}" ;;
		''|.) shift ;;
		..) realpath.dirname "$REPLY"; shift ;;
		*) REPLY="${REPLY%/}/$1"; shift ;;
	esac; done; ${eg:+shopt -u $eg}
}

realpath.canonical() {
	realpath.follow "$1"; set -- "$REPLY"   # $1 is now resolved
	realpath.basename "$1"; set -- "$1" "$REPLY"   # $2 = basename $1
	realpath.dirname "$1"
	[[ $REPLY != "$1" ]] && realpath.canonical "$REPLY"; # recurse unless root
	realpath.absolute "$REPLY" "$2";   # combine canon parent w/basename
}

realpath.relative() {
	local target=""
	realpath.absolute "$1"; set -- "$REPLY" "${@:2}"; realpath.absolute "${2-$PWD}" X
	while realpath.dirname "$REPLY"; [[ "$1" != "$REPLY" && "$1" == "${1#${REPLY%/}/}" ]]; do
		target=../$target
	done
	[[ $1 == "$REPLY" ]] && REPLY=${target%/} || REPLY="$target${1#${REPLY%/}/}"
	REPLY=${REPLY:-.}
}
# For documentation, see https://github.com/bashup/loco

set -euo pipefail

fn_exists() { declare -F -- "$1"; } >/dev/null
fn_copy()   { REPLY="$(declare -f "$1")"; eval "$2 ${REPLY#$1}"; }
findup()    { walkup "${1:-$PWD}" reply_if_exists "${@:2}"; }

reply_if_exists() {
    local pat dir=$1 IFS= ; shift
    for pat; do
        for REPLY in ${dir%/}/$pat; do [[ -f "$REPLY" ]] && return 0; done
    done
    return 1
}

walkup() {
    realpath.absolute "$1"
    until set -- "$REPLY" "${@:2}"; "$2" "$1" "${@:3}"; do
        [[ "$1" != "/" ]] || return 1; realpath.dirname "$1"
    done
}

_loco_usage() { loco_error "Usage: $LOCO_COMMAND command args..."; }
_loco_error() { echo "$@" >&2; exit 64; }
_loco_cmd() { REPLY="$LOCO_NAME.$1"; }
_loco_exec() { loco_error "Unrecognized command: $1"; }
_loco_exists() { type -t "$1"; } >/dev/null

_loco_do() {
    [[ "${1-}" ]] || loco_usage   # No command given, exit w/usage
    REPLY=""; loco_cmd "$1"; local cmd="$REPLY"
    [[ "$cmd" ]] || loco_usage   # Unrecognized command, exit w/usage

    if loco_exists "$cmd"; then
        # Command, alias, function, or builtin exists
        shift; "$cmd" "$@"
    else
        # Invoke the default command interpreter
        loco_exec "$@"
    fi
}

_loco_findproject() {
    # shellcheck disable=SC2015  # plain var assign can't be false
    findup "$LOCO_PWD" "${LOCO_FILE[@]}" && LOCO_PROJECT=$REPLY ||
        loco_error "Can't find $LOCO_FILE here";
}
_loco_preconfig() { true; }
_loco_postconfig() { true; }
_loco_findroot() { realpath.dirname "$LOCO_PROJECT"; LOCO_ROOT=$REPLY; }
_loco_loadproject() { cd "$LOCO_ROOT";  $LOCO_LOAD "$1"; }
_loco_site_config() { source "$1"; }
_loco_user_config() { source "$1"; }


# Find our configuration, exposing relevant paths and defaults

# shellcheck disable=SC2034  # some vars are only used by extending scripts
_loco_config() {
    LOCO_ARGS=("$@")
    loco_preconfig "$@"
    ${LOCO_COMMAND:+:} realpath.basename "$LOCO_SCRIPT"; LOCO_COMMAND="${LOCO_COMMAND-$REPLY}"
    LOCO_NAME="${LOCO_NAME-${LOCO_COMMAND}}"
    LOCO_PWD="${LOCO_PWD-$PWD}"

    LOCO_SITE_CONFIG="${LOCO_SITE_CONFIG-/etc/$LOCO_NAME/config}"
    [ -f "$LOCO_SITE_CONFIG" ] && loco_site_config "$LOCO_SITE_CONFIG"
    LOCO_RC="${LOCO_RC-.${LOCO_NAME}rc}"
    LOCO_USER_CONFIG="${LOCO_USER_CONFIG-$HOME/$LOCO_RC}"
    [ -f "$LOCO_USER_CONFIG" ] && loco_user_config "$LOCO_USER_CONFIG"

    [[ ${LOCO_FILE-} ]] || LOCO_FILE=(".$LOCO_NAME")
    LOCO_LOAD="${LOCO_LOAD-source}"
    loco_postconfig "$@"
}

_loco_main() {
    loco_config "$@"
    fn_exists "$LOCO_NAME" || eval "$LOCO_NAME() { loco_do \"\$@\"; }"
    ${LOCO_PROJECT:+:} loco_findproject "$@"
    ${LOCO_ROOT:+:}    loco_findroot "$@"
    loco_loadproject "$LOCO_PROJECT"
    loco_do "$@"
}

# Initialize default function implementations
for f in $(compgen -A function _loco_); do
    fn_exists "${f#_}" || fn_copy "$f" "${f#_}"
done

# Clear all LOCO_*  variables before beginning
for lv in ${!LOCO_@}; do unset "$lv"; done

LOCO_SCRIPT=$0
project-is-finalized() { [[ ${DOCO_CONFIG-} ]]; }
loco_preconfig() {
    set -- "${BASH_VERSINFO[@]}"
    (( $1 > 4 || $1 == 4 && $2 >= 4 )) || mdsh-error "Sorry; doco requires bash 4.4 or better"
    export COMPOSE_PROJECT_NAME=
    LOCO_FILE=("?*[-.]doco.md" ".doco" "docker-compose.yml")
    LOCO_NAME=doco
    LOCO_USER_CONFIG=$HOME/.config/doco
    LOCO_SITE_CONFIG=/etc/doco/config
}
loco_loadproject() {
    cd "$LOCO_ROOT"; [[ ! -f .env ]] || export-env .env
    export COMPOSE_FILE=$LOCO_ROOT/.doco-cache.json COMPOSE_PATH_SEPARATOR=$'\n'
    local json=$COMPOSE_FILE; DOCO_CONFIG=

    realpath.basename "$1"; case "$REPLY" in
    ?*[-.]doco.md)
        check_multi doco.md '?*[-.]doco.md'
        include "$1" "$LOCO_ROOT/.doco-cache.sh"
        ;;
    *)
        compose-variants "" load_yaml; compose-variants ".override" add_override
        [[ ! -f .doco ]] || source .doco
        ;;
    esac

    event fire "finalize_project"  # allow overriding the final compose project def
    RUN_JQ -c -n >"$json"; DOCO_CONFIG=$json; services-matching || return
    DOCO_CONFIG='' GROUP --all := "${REPLY[@]}"   # ensure SERVICES exist for all services
    target --all readonly          # make --all a read-only group
    event fire "before_commands"   # hook to set up aliases, custom commands, etc.
}

# Run a command with variants accepted by docker-compose, first checking that
# no more than one such variant exists
compose-variants() {
    check_multi "docker-compose$1" "docker-compose$1.yml" "docker-compose$1.yaml"
    "${@:2}" "$LOCO_ROOT/docker-compose$1.yml" "$LOCO_ROOT/docker-compose$1.yaml"
}

# Load listed YAML files as JSON, if they exist
load_yaml() { while (($#)); do [[ ! -f "$1" ]] || JSON "$(yaml2json /dev/stdin <"$1")"; shift; done; }

# Add a file to the COMPOSE_FILE list
add_override() { while (($#)); do [[ ! -f "$1" ]] || COMPOSE_FILE+=$'\n'"$1"; shift; done; }

# Abort if more than one given filename exists
check_multi() {
   # shellcheck disable=SC2012,SC2068  # we're using wc and glob expansion is intentional
   (("$(ls ${@:2} 2>/dev/null | wc -l)" < 2)) || loco_error "Multiple $1 files in $LOCO_ROOT"
}
GROUP() {
    (($#>1)) || loco_error "GROUP requires at least two arguments"
    local op groups=(); while (($#)) && [[ $1 != [+:/]= ]]; do groups+=("$1"); shift; done
    for svc in "${@:2}"; do target "$svc" exists || target "$svc" declare-service || return; done
    case "${1-}" in
        +=) op='add' ;;
        :=) op='set' ;;
        /=) op='set-default' ;;
        *) fail "GROUP needs an operator: +=, :=, or /=" || return
    esac
    [[ ${groups[*]-} ]] || fail "No groups given" || return
    for REPLY in "${groups[@]}"; do target "$REPLY" "$op" "${@:2}"; done
}
SERVICES() { for REPLY; do target "$REPLY" declare-service; done; }
VERSION() { FILTER ".version=\"$1\""; }
export-env() {
    while IFS= read -r; do
        REPLY="${REPLY#"${REPLY%%[![:space:]]*}"}"  # trim leading whitespace
        REPLY="${REPLY%"${REPLY##*[![:space:]]}"}"  # trim trailing whitespace
        [[ ! "$REPLY" || "$REPLY" == '#'* ]] || export "${REPLY?}"
    done <"$1"
}
export-source() {
    local before="" after=""
    before="$(compgen -v)"; source "$@"; after="$(compgen -v)"
    after="$(echo "$after" | grep -vxF -f <(echo "$before"))" || true
    [[ -z "$after" ]] || eval "export $after"
}
include() {
    realpath.absolute "$1"
    if [[ ! "${2-}" ]]; then
        local MDSH_CACHE="$LOCO_ROOT/.doco-cache/includes"
        @require "doco-include:$REPLY" mdsh-run "$1" ""
    else
        __include() { mdsh-make "$1" "$2"; source "$2"; }
        @require "doco-include:$REPLY" __include "$@"
    fi
}
#!/usr/bin/env bash
event(){ case $1 in error|quote|encode|decode);; *)
	__ev.encode "${2-}";local f n='' e=bashup_event_$REPLY;f=${e/event/flag}
	case $1 in emit) shift;${!f-};eval "${!e-}"; return ;;on|once|off|has)
		case "${3-}" in @_) n='$#';; @*[^0-9]*);; @[0-9]*) n=$((${3#@}));; esac; ${n:+
		set -- "$1" "$2" "${@:4}" }
		case $1/$# in
			has/[12]) REPLY=;; */[12]) set -- error "${2-}: missing callback";;
			*) __ev.quote "${@:3}";((${n/\$#/1}))&&REPLY+=' "${@:2:'"$n"'}"';REPLY+=$'\n'
		esac
	esac
esac ;__ev."$@";}
__ev.error(){ echo "$1">&2;return "${2:-64}";}
__ev.quote(){ REPLY=; ${@+printf -v REPLY ' %q' "$@"}; REPLY=${REPLY# };}
__ev.has(){ [[ ${!e-} && $'\n'"${!e}" == *$'\n'"$REPLY"* && ! ${!f-} ]];}
__ev.on(){ __ev.has && return;if [[ ! ${!f-} ]];then eval "$e"+='$REPLY';else eval "${!e-};$REPLY";fi;}
__ev.off(){ __ev.has||return 0; n="${!e}"; n=${n#"$REPLY"}; eval "$e"=$'"${n//\n"$REPLY"/\n}"';}
__ev.fire(){ ${!f-};set -- "$e" "${@:2}"; while [[ ${!1-} ]];do eval "$1=;${!1}"; done ;}
__ev.all(){ ${!f-};e=${!e-};eval "${e//$'\n'/||return; }";}
__ev.any(){ ${!f-};e=${!e-};eval "${e//$'\n'/&&return|| } ! :";}
__ev.resolve(){
	${!f-};__ev.fire "$@";__ev.quote "$@"
	readonly "$f=eval __ev.error 'event \"'$1'\" already resolved' 70;return" "$e=set -- $REPLY"
}
__ev.resolved(){ [[ ${!f-} ]];}
__ev.once(){ n=${n:-0} n=${n/\$#/_}; event on "$1" "@$n" __ev_once $# "@$n" "$@";}
__ev_once(){ event off "$3" "$2" __ev_once "${@:1:$1+2}"; "${@:4}";}
__ev_jit(){
	local r=${__ev_jit-} s=$1;((${#r}<250))||__ev_jit=
	while [[ "$s" ]]; do
		r=${s::1};s=${s//$r/};printf -v r 'REPLY=${REPLY//%q/_%02x};' "$r" "'$r";eval "$r";__ev_jit+=$r
	done
	eval '__ev.encode(){ local LC_ALL=C;REPLY=${1//_/_5f};'\
	"${__ev_jit-}"' [[ $REPLY != *[^_[:alnum:]]* ]] || __ev_jit "${REPLY//[_[:alnum:]]/}";}'
};__ev_jit ''
__ev.decode(){ REPLY=();while (($#));do printf -v REPLY[${#REPLY[@]}] %b "${1//_/\\x}";shift;done;}
__ev.list(){ eval 'set -- "${!'"$e"'@}"';__ev.decode "${@#bashup_event_}";}
is-target-name() { [[ $1 && $1 != *[^-._A-Za-z0-9]* ]]; }

target() {
	local TARGET_NAME="$1" __mro__=(doco-target)
	if is-target-name "$1"; then
		local t=${1//_/_5f}; t=${t//./_2e}; t=${t//-/_2d}
		local TARGET_VAR=__doco_target_$t
	elif [[ $1 == @current ]]; then
		local TARGET_VAR=DOCO_SERVICES __mro__=(@current-target doco-target)
	else fail "Group or service name '$1' contains invalid characters" || return
	fi
	local -n TARGET="$TARGET_VAR"
	local TARGET_OLD=${TARGET[*]-}
	this "${@:2}"
}

fail() { echo "$1">&2; return "${2-64}"; }
this() {
	if (($#)); then
		local m; for m in "${__mro__[@]}"; do if fn-exists "$m::$1"; then break; fi; done
		"$m::$@"
	fi
}

doco-target::is-service() { [[ ${TARGET[*]-} == "$TARGET_NAME" ]]; }
doco-target::is-group() { this exists && ! this is-service; }
doco-target::exists() { [[ ${TARGET+_} ]] || declare -p "$TARGET_VAR" >/dev/null 2>&1; }

doco-target::declare-service() {
	if ! this exists; then
		if project-is-finalized; then
			fail "$TARGET_NAME: services must be created before project spec is finalized" ||
			return
		fi
		this __create service "$TARGET_NAME"
		this readonly "$@"
	elif ! this is-service; then
		fail "$TARGET_NAME is a group, but a service was expected"
	fi
}

doco-target::declare-group() {
	if ! this exists; then
		this __create group
		this "$@"
	elif this is-service; then
		fail "$TARGET_NAME is a service, but a group was expected"
	fi
}

doco-target::__create() {
	TARGET=("${@:2}")
	event emit    "create $1" "$TARGET_NAME"
	event resolve "created $1 $TARGET_NAME" "$TARGET_NAME"
}

doco-target::get() { REPLY=("${TARGET[@]}"); this "$@"; }
doco-target::has-count() { this get; eval "(( ${#REPLY[@]} ${1-} ))"; }

doco-target::readonly() { readonly "${TARGET_VAR}"; this "$@"; }

doco-target::add() { this set "$TARGET_NAME" "$@"; }
doco-target::set() {
	this declare-group || return
	all-targets "$@" || return
	TARGET=("${REPLY[@]}")
	if [[ ${TARGET[*]-} != "$TARGET_OLD" ]]; then
		event emit "change group" "$TARGET_NAME" "${TARGET[@]}"
	fi
}

doco-target::set-default() { this exists || this set "$@"; }

doco-target::foreach() {
	this get; for REPLY in "${REPLY[@]}"; do with-targets "$REPLY" -- "$@"; done
}
@current-target::set() { fail "@current group is read-only"; }
@current-target::declare-service() { fail "@current is a group, but a service was expected"; }
@current-target::declare-group() { :; }

@current-target::exists() { [[ ${HAVE_SERVICES-} ]]; }
@current-target::get() {
	REPLY=(); [[ ! ${HAVE_SERVICES-} ]] || REPLY=("${TARGET[@]}"); this "$@"
}

with-targets() {
	local s=(); while (($#)) && [[ $1 != -- ]]; do s+=("$1"); shift; done
	all-targets "${s[@]}" || return
	__apply-targets = "${REPLY[@]}" -- "${@:2}"
}

without-targets() { __apply-targets '' -- "$@"; }

__apply-targets() {
	local HAVE_SERVICES=$1 DOCO_SERVICES DOCO_COMMAND
	DOCO_SERVICES=(); shift
	while (($#)) && [[ $1 != -- ]]; do DOCO_SERVICES+=("$1"); shift; done
	readonly DOCO_SERVICES
	"${@:2}"
}
# set REPLY to merge of all given target names
all-targets() {
	local services=()
	while (($#)); do
		target "$1" get exists || [[ $1 == @current ]] ||
			fail "'$1' is not a known group or service" || return
		for REPLY in "${REPLY[@]}"; do
			[[ " ${services[*]-} " == *" $REPLY "* ]] || services+=("$REPLY")
		done
		shift
	done
	REPLY=("${services[@]}")
}

# set REPLY to contents of the first existing target
any-target() {
	for REPLY; do
		if target "$REPLY" get exists; then return ; fi
	done
	REPLY=(); false
}

foreach-service() { target @current foreach "$@"; }
have-services() { target @current has-count "$@"; }
project-name() {
    REPLY=${COMPOSE_PROJECT_NAME-}
    [[ $REPLY ]] || realpath.basename "$LOCO_ROOT"   # default to directory name
    REPLY=${REPLY//[^[:alnum:]]/}; REPLY=${REPLY,,}  # lowercase and remove non-alphanumerics
    ! (($#)) || REPLY=$REPLY"_${1}_${2-1}"           # container name
}
quantify-services() {
	[[ ${1-} == [-+1.] ]] ||
		fail "service quantifier must be ., -, +, or 1" || return
	set -- "$1" "${2-}" "${@:3}"
	set -- "$1$(($#-2))" "${2:-${DOCO_COMMAND:-the current command}}"
	case $1 in
		?1|-0|.*) return ;;  # 1 is always acceptable
		?0)    fail "no services specified for $2" ;;
		[-1]*) fail "$2 cannot be used on multiple services" ;;
	esac
}
require-services() {
	if (($#>2)); then any-target "${@:3}" || true; else target @current get; fi
	quantify-services "${1-}" "${2-}" "${REPLY[@]}"
}
services-matching() {
	REPLY=()
	local t="services_matching(${1-true}) | .key"
	t="$(
		[[ ${DOCO_CONFIG:+_} ]] || JQ_OPTS -n;
		RUN_JQ -r "$t" ${DOCO_CONFIG:+"$DOCO_CONFIG"}
	)" &&
	IFS=$'\n' mdsh-splitwords "$t"
}
mdsh_raw_jq_api+=($'def services: if .services // .version then .services else . end;\n')
mdsh_raw_jq_api+=($'def services_matching(f): services // {} | to_entries | .[] | select( .value | f ) ;\n')
event on "create service" @1 event on "RUN_JQ" generate-jq-func
event on "create group"   @1 event on "RUN_JQ" generate-jq-func

RUN_JQ() {
	local jqmd_defines=${jqmd_defines-}
	event emit "RUN_JQ"  # allow on-the-fly defines
	JQ_CMD "$@" && "${REPLY[@]}"
}

generate-jq-func() {
    if [[ $1 != "@current" ]]; then
        target "$1" get; set -- "$1" "${REPLY[@]}"
        local t=; (($#<2)) || { printf -v t '| (.services."%s" |= f ) ' "${@:2}"; t=${t:2}; }
        # jq function names can only have '_' or '::', not '-' or '.'
        set -- "${1//-/::dash::}"; set -- "${1//./::dot::}"; set -- "${1/#::/_::}"
        set -- "${1//::::/::}"
        DEFINE "def $1(f): ${t:-.};"
    fi
}
ALIAS() { mdsh-splitwords "$1"; GROUP "${REPLY[@]}" += "${@:2}"; }
alias-exists() { target "$1" exists; }
get-alias() { target "$1" get; }
set-alias() { target "$1" set "$@"; }
with-alias() { target "$1" call "${@:2}"; }
with-service() { mdsh-splitwords "$1"; with-targets @current "${REPLY[@]}" -- "${@:2}"; }
find-services() { services-matching "$@"; }
# doco opt OPTION CMD...  --> run CMD with OPTION added to project options
doco-opt() { local DOCO_OPTS=("${DOCO_OPTS[@]}" "$1"); "${@:2}"; }

# compose SUBCOMMAND... --> docker-compose DOCO_OPTS SUBCOMMAND...
compose() { docker-compose "${DOCO_OPTS[@]}" "$@"; }

# Global docker-compose flags
doco.--verbose()   { doco-opt --verbose   doco "$@"; }
doco.--no-ansi()   { doco-opt --no-ansi   doco "$@"; }
doco.--tls()       { doco-opt --tls       doco "$@"; }
doco.--tlsverify() { doco-opt --tlsverify doco "$@"; }

doco.--skip-hostname-check() { doco-opt --skip-hostname-check doco "$@"; }

# Options that take arguments
function doco.-H=()          { doco-opt -H="$1"          doco "${@:2}"; }
function doco.--host=()      { doco-opt --host="$1"      doco "${@:2}"; }
function doco.--tlscacert=() { doco-opt --tlscacert="$1" doco "${@:2}"; }
function doco.--tlscert=()   { doco-opt --tlscert="$1"   doco "${@:2}"; }
function doco.--tlskey=()    { doco-opt --tlskey="$1"    doco "${@:2}"; }

# Informational options
doco.-h()        { docker-compose -h        "$@"; }
doco.-v()        { docker-compose -v        "$@"; }
doco.--help()    { docker-compose --help    "$@"; }
doco.--version() { docker-compose --version "$@"; }

# Project options can't be set on the command line

function doco.--project-name=() {
	loco_error "You must use COMPOSE_PROJECT_NAME to set the project name."
}
function doco.--file=() {
	loco_error "doco does not support -f and --file."
}
function doco.--project-directory=() {
	loco_error "doco: --project-directory cannot be overridden"
}
function doco.-f=() { doco --file "$@"; }
function doco.-p=() { doco --project-name "$@"; }

# All supported docker-compose subcommands should be placed here
doco.build()   { compose-targeted   build   "$@"; }
doco.bundle()  { compose-untargeted bundle  "$@"; }
doco.config()  { compose-untargeted config  "$@"; }
doco.create()  { compose-targeted   up --no-start "$@"; }
doco.down()    { compose-untargeted down    "$@"; }
doco.events()  { compose-targeted   events  "$@"; }
doco.exec()    { compose-singular   exec \
	'-e|--env|-u|--user|--index' "$@"; }
doco.help()    { docker-compose     help    "$@"; }
doco.images()  { compose-targeted   images  "$@"; }
doco.kill()    { compose-targeted   kill    "$@"; }
doco.logs()    { compose-targeted   logs    "$@"; }
doco.pause()   { compose-targeted   pause   "$@"; }
doco.port()    { compose-singular   port \
	'--protocol|--index' "$@"; }
doco.ps()      { compose-targeted   ps      "$@"; }
doco.pull()    { compose-targeted   pull    "$@"; }
doco.push()    { compose-targeted   push    "$@"; }
doco.restart() { compose-targeted   restart "$@"; }
doco.rm()      { compose-targeted   rm      "$@"; }
doco.run()     { compose-singular   run \
	'-p|--publish|-v|--volume|-w|--workdir|-e|--env|-u|--user|--name|--entrypoint' "$@"; }
doco.scale()   { compose-untargeted scale   "$@"; }
doco.start()   { compose-targeted   start   "$@"; }
doco.stop()    { compose-targeted   stop    "$@"; }
doco.top()     { compose-targeted   top     "$@"; }
doco.unpause() { compose-targeted   unpause "$@"; }
doco.up()      { compose-targeted   up      "$@"; }
doco.version() { docker-compose     version "$@"; }

compose-defaults() {
	set -- "${DOCO_COMMAND:-${1-}}" "$@"; [[ $1 && $1 != "${2-}" ]] || shift
	set -- "${@/#/--}"; any-target @current "${@/%/-default}" --default
}
# Commands that accept services
compose-targeted() {
	if compose-defaults "$1"; then
		# Non-default target; make sure it's not empty
		quantify-services + "${DOCO_COMMAND:-$1}" "${REPLY[@]}" || return
    fi
	compose "$@" "${REPLY[@]}"
}
# Commands that don't accept a list of services
compose-untargeted() {
	target @current has-count ==0 || fail "$1 cannot target specific services" || return
	compose "$@";
}
compose-singular() {
	local svc cmd=$1 opts=^$2\$ argv=("$1"); shift

	# Parse the command line, skipping options' argument values
	while shift && (($#)) && [[ $1 == -* ]]; do
		# Treat '--' as end of options
		if [[ $1 == -- ]]; then shift; break; fi
		argv+=("$1"); if [[ $1 =~ $opts ]]; then shift; argv+=("$1"); fi
    done

	if ! compose-defaults "$cmd"; then
		# no current or default target, check command line for one and remove it
		if is-target-name "${1-}" && target "$1" get exists; then shift; fi
	fi

	quantify-services 1 "${DOCO_COMMAND:-$cmd}" "${REPLY[@]}" || return
	compose "${argv[@]}" "${REPLY[@]}" "$@"
}

doco_had_args=0  # times doco has been called with arguments

loco_do() {
	project-is-finalized ||
		fail "doco CLI cannot be used before the project spec is finalized" || return
	(( ! $# )) || doco_had_args=1
	case ${1-} in
		--*=*)    doco-optarg  "$@" ;;  # --[option]=value
		--*)      doco-option  "$@" ;;  # --[option]
		-[^=]=*)  doco-optarg  "$@" ;;  # -a=bcd
		-[^=]?*)  doco-options "$@" ;;  # -abcd
		-?)       doco-option  "$@" ;;  # -x
		'')       doco-null    "$@" ;;  # empty or missing command
		*)        doco-other   "$@" ;;  # commands, services, and groups
	esac
}
doco-null() {
	if ((doco_had_args && ! $#)); then
		target "@current" get
		${REPLY[@]+printf '%s\n' "${REPLY[@]}"}  # only output lines if there are some
	else
		loco_usage   # No non-empty command given and no targets specified, exit w/usage
	fi
}
doco-options() {
	if fn-exists "doco.${1:0:2}="; then
		"doco.${1:0:2}=" "${1:2}" "${@:2}"  # -a= bcd ...
	elif fn-exists "doco.${1:0:2}"; then
		"doco.${1:0:2}" "-${1:2}" "${@:2}"  # -a -bcd ...
	else doco-other "$@"   # maybe -abcd is a command, group, or service?
	fi
}

doco-option() {
	if fn-exists "doco.$1"; then "doco.$@"
	elif fn-exists "doco.$1="; then
		if (($#>1)); then "doco.$1=" "${@:2}"
		else fail "$1 requires an argument"
		fi
	else doco-other "$@"   # maybe --longopt is a group or service?
	fi
}

doco-optarg() {
	if fn-exists "doco.${1%%=*}="; then
		"doco.${1%%=*}=" "${1#*=}" "${@:2}"
	elif fn-exists "doco.${1%%=*}"; then
		fail "${1%%=*} does not accept values"
	else doco-other "$@"   # maybe it's a command/group/service?
	fi
}
doco-other() {
	if fn-exists "doco.$1"; then
		with-command "${DOCO_COMMAND:-$1}" "doco.$@"
	elif is-target-name "$1" && target "$1" exists; then
		with-targets @current "$1" -- doco "${@:2}"
	else fail "'$1' is not a recognized option, command, service, or group"
	fi
}

with-command() { local DOCO_COMMAND=$1; "${@:2}"; }
# Execute the rest of the command line without specified services
doco.--() { without-targets doco "$@"; }
doco.--dry-run() {
	docker() { printf -v REPLY ' %q' "docker" "$@"; echo "${REPLY# }"; } >&2
	docker-compose() { printf -v REPLY ' %q' "docker-compose" "$@"; echo "${REPLY# }"; } >&2
	((! $#)) || { doco "$@"; unset -f docker docker-compose; }
}
function doco.--where=() {
    services-matching "${@:1}"
    with-targets @current "${REPLY[@]}" -- doco "${@:2}"   # run command on matching services
}
# Execute the rest of the command line with specified service(s)
function doco.--with=() {
	mdsh-splitwords "$1"; with-targets @current "${REPLY[@]}" -- doco "${@:2}"
}
function doco.--with-default=() {
    if target @current has-count || ! target "$1" exists; then doco "${@:2}"
    else with-targets "$1" -- with-command "${DOCO_COMMAND-}" doco "${@:2}"; fi
}
function doco.--require-services=() {
    [[ ${1:0:1} == [-+1.] ]] || loco_error "--require-services argument must begin with ., -, +, or 1"
    mdsh-splitwords "$1"; ((${#REPLY[@]}>1)) || REPLY+=("${DOCO_COMMAND:-${2-}}")
    require-services "${REPLY[@]:0:2}" && doco "${@:2}"
}
doco.cmd() {
	[[ ${DOCO_COMMAND-} != cmd ]] || local DOCO_COMMAND=$2
	doco --with-default cmd-default --require-services "$@"
}
doco.cp() {
    local opts=() seen=''
    while (($#)); do
        case "$1" in
        -a|--archive|-L|--follow-link) opts+=("$1") ;;
        --help|-h) docker help cp || true; return ;;
        -*) fail "Unrecognized option $1; see 'docker help cp'" || return ;;
        *) break ;;
        esac
        shift
    done
    (($# == 2)) || fail "cp requires two non-option arguments (src and dest)" || return
    while (($#)); do
        if [[ $1 == *:* ]]; then
            [[ ! "$seen" ]] || fail "cp: only one argument may contain a :" || return
            seen=yes
            if [[ "${1%%:*}" ]]; then
                project-name "${1%%:*}"; set -- "$REPLY:${1#*:}" "${@:2}"
            else
                require-services 1 cp @current shell-default || return
                project-name "$REPLY"; set -- "$REPLY$1" "${@:2}"
            fi
        elif [[ $1 != /* && $1 != - ]]; then
            # make paths relative to original run directory
            set -- "$LOCO_PWD/$1" "${@:2}";
        fi
        opts+=("$1"); shift
    done
    [[ "$seen" ]] || fail "cp: either source or destination must contain a :" || return
    docker cp ${opts[@]+"${opts[@]}"}
}
doco.foreach() { foreach-service doco "$@"; }
doco.jq() { RUN_JQ "$@" <"$DOCO_CONFIG"; }
doco.sh() { doco --with-default cmd-default exec bash "$@"; }
DEFINE "${mdsh_raw_jq_api[*]}"

# shellcheck disable=SC2059  # argument is a printf format string
mdsh-error() { printf -v REPLY "$1"'\n' "${@:2}"; loco_error "$REPLY"; }
if [[ $0 == "${BASH_SOURCE-}" ]]; then loco_main "$@"; fi
